
vector<ll> I;
const ll mod = (119 << 23) + 1, root = 3; // = 998244353
//remember to also write mod_pow
typedef vector<ll> vl;
void ntt(ll* x, ll* temp, ll* roots, int n, int skip) {
    if (n == 1) return;
    int n2 = n/2;
    ntt(x     , temp, roots, n2, skip*2);
    ntt(x+skip, temp, roots, n2, skip*2);
    for(int i =0; i < n; i++) temp[i] = x[i*skip];
    for(int i = 0; i < n2; i++) {
        ll s = temp[2*i], t = temp[2*i+1] * roots[skip*i];
        x[skip*i] = (s + t) % mod; x[skip*(i+n2)] = (s - t) % mod;
    }
}
ll modpow(ll b, ll e){
    if(!e)return 1;
    if(e&1)return b * modpow(b,e-1) % mod;
    return modpow(b*b%mod,e>>1);
}
void ntt(vl& x, bool inv = false) {
    ll e = modpow(root, (mod-1) / x.size());
    if (inv) e = modpow(e, mod-2);
    vl roots(x.size(), 1), temp = roots;
    for(int i = 1; i < x.size(); i++) roots[i] = roots[i-1] * e % mod;
    ntt(&x[0], &temp[0], &roots[0], x.size(), 1);
}
vl conv(vl a, vl b) {
    int s = a.size() + b.size() - 1; if (s <= 0) return {};
    int L = s > 1 ? 32 - __builtin_clz(s - 1) : 0, n = 1 << L;
    if (s <= 200) { // (factor 10 optimization for |a|,|b| = 10)
        vl c(s);
        for(int i = 0; i < a.size(); i++)for(int j = 0; j < b.size(); j++)
                c[i + j] = (c[i + j] + a[i] * b[j]) % mod;
        return c;
    }
    a.resize(n); ntt(a);
    b.resize(n); ntt(b);
    vl c(n); ll d = modpow(n, mod-2);
    for(int i = 0; i < n; i++) c[i] = a[i] * b[i] % mod * d % mod;
    ntt(c, true); c.resize(s); return c;
}
vector<ll> fpconv(int n) {
    if (n == 1) {
        return I;
    }
    auto ret = fpconv(n >> 1);
    if (n & 1) {
        ret = conv(ret,ret);
        ret = conv(ret,I);
    } else {
        ret = conv(ret,ret);
    }
    return ret;
}

